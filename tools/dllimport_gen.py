import subprocess, sys, os

# TODO: Add way to detect the toolchain

def popen_and_read_stdout(args : list) -> str :
    proc = subprocess.run(args, capture_output = True)
    return proc.stdout.decode('utf-8')
def extract_symbols_msvc(path : str) -> list :
    dumpbin = 'C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.33.31629/bin/Hostx86/x86/dumpbin.exe'
    ret = popen_and_read_stdout([dumpbin, '/EXPORTS', path])
    result = []

    for line in ret.splitlines() :
        part = line.split(' ')
        npart = []
        # Remove empty item in part
        for i in part :
            if i != '' :
                npart.append(i)
        # 4 in ['1696', 'BC', '0002A3A0', 'DispatchMessageA']
        # 6 in ['1675', 'A6', 'DefWindowProcA', '(forwarded', 'to', 'NTDLL.NtdllDefWindowProc_A)']
        if len(npart) < 4 :
            continue
        if not npart[0].isdigit():
            continue
        if npart[1] == 'number' :
            continue
        if len(npart) == 4 :
            # print(npart)
            result.append(npart[3])
        if len(npart) == 6 :
            # print(npart)
            result.append(npart[2])
        pass
    return result
def extract_symbols_gcc(path : str) -> list :
    raise NotImplementedError()
def extract_symbols(path) -> list :
    if sys.platform == 'win32' :
        return extract_symbols_msvc(path)
    else :
        return extract_symbols_gcc(path)

def process_path(path : str) -> str :
    if os.path.isabs(path) :
        return path

    # Check has extension name if
    if path.find('.') == -1 :
        if sys.platform == 'win32' :
            path += '.dll'
        if sys.platform == 'linux' :
            path += '.so'

    if sys.platform == 'win32' :
        if os.access('C:/Windows/System32/' + path, os.F_OK) :
            return 'C:/Windows/System32/' + path
    if sys.platform == 'linux' :
        if os.access('/usr/lib/' + path, os.F_OK) :
            return '/usr/lib/' + path
    else :
        return path

def gen_dllimport_header(path : str, symbols : list = []) -> str :
    if len(symbols) == 0 :
        symbols = extract_symbols(path)
    lib = os.path.basename(path)
    libname = '_dllimport_' + lib.replace('.', '_')
    varname = '_dllinstance_' + lib.replace('.', '_')


    out = ' /* Generated by dllimport_gen.py DO NOT EDIT IT !!! */\n'
    out += '#pragma once\n\n'
    out += 'LIB_BEGIN(%s, "%s") \n' % (libname, lib)

    for sym in symbols :
        out += '    LIB_PROC(%s) \n' % sym
    
    out += 'LIB_END(%s) \n\n' % (libname)

    # Table end

    # Generate defined macros
    out += 'static %s %s;\n\n' % (libname, varname)
    # out += 'static uint8_t %s[sizeof(%s)]; \n' % (varname, libname)
    # out += 'static bool    %s_inited = false; \n' % (varname)

    for sym in symbols :
        # out += '#define %s(...) (!%s_inited : (new(&%s) %s, %s_inited = true) ? nullptr , static_cast<%s*>(&%s)->%s(__VA_ARGS__))\n' % (sym, varname, varname, varname, libname, libname, varname, sym)
        out += '#define %s(...) (%s->%s(__VA_ARGS__))\n' % (sym, varname, sym)
        pass
    print(out)

    return out

def main() :
    # symbols = extract_symbols('C:/Windows/System32/user32.dll')
    # for sym in symbols :
    #     print(sym)
    # pass
    if len(sys.argv) == 2 :
        gen_dllimport_header(process_path(sys.argv[1]))
    if len(sys.argv) == 3 :
        # dll, file to replace
        path = process_path(sys.argv[1])
        file = sys.argv[2]

        symbols = extract_symbols(path)
        nsymbols = []
        # Read file
        with open(file, 'r') as f : 
            txt = f.read()
            for sym in symbols :
                if txt.find(sym) == -1 :
                    continue
                nsymbols.append(sym)
        
        gen_dllimport_header(path, symbols = nsymbols)

if __name__ == '__main__' :
    main()